.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DRI::Protocol::ResultStatus 3pm"
.TH Net::DRI::Protocol::ResultStatus 3pm "2012-08-08" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DRI::Protocol::ResultStatus \- Encapsulate Details of an Operation Result (with Standardization on EPP) for Net::DRI
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class represents all details of an operation result as given back from the registry,
with standardization on \s-1EPP\s0 as much as possible, for error codes and list of fields available.
.PP
When an operation is done, data retrieved from the registry is also stored inside the ResultStatus object
(besides being available through \f(CW\*(C`$dri\-\*(C'\fR\fIget_info()\fR>). It can be queried using the \f(CW\*(C`get_data()\*(C'\fR and
\&\f(CW\*(C`get_data_collection\*(C'\fR methods as explained below. The data is stored as a ref hash with 3 levels:
the first keys have as values a reference to another hash where keys are again associated with values
being a reference to another hash where the content (keys and values) depends on the registry, the operation
attempted, and the result.
.PP
Some data will always be there: a \*(L"session\*(R" first key, with a \*(L"exchange\*(R" subkey, will have a reference to
an hash with the following keys:
.IP "duration_seconds" 4
.IX Item "duration_seconds"
the duration of the exchange with registry, in a floating point number of seconds
.IP "raw_command" 4
.IX Item "raw_command"
the message sent to the registry, as string
.IP "raw_reply" 4
.IX Item "raw_reply"
the message received from the registry, as string
.IP "result_from_cache" 4
.IX Item "result_from_cache"
either 0 or 1 if these results were retrieved from Net::DRI Cache object or not
.IP "object_action" 4
.IX Item "object_action"
name of the action that has been done to achieve these results (ex: \*(L"info\*(R")
.IP "object_name" 4
.IX Item "object_name"
name (or \s-1ID\s0) of the object on which the action has been performed (not necessarily always defined)
.IP "object_type" 4
.IX Item "object_type"
type of object on which this operation has been done (ex: \*(L"domain\*(R")
.IP "registry, profile, transport, protocol" 4
.IX Item "registry, profile, transport, protocol"
registry name, profile name, transport name+version, protocol name+version used for this exchange
.IP "trid" 4
.IX Item "trid"
transaction \s-1ID\s0 of this exchange
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIis_success()\fP"
.IX Subsection "is_success()"
returns 1 if the operation was a success
.SS "\fIcode()\fP"
.IX Subsection "code()"
returns the \s-1EPP\s0 code corresponding to the native code (which depends on the registry)
for this operation (see \s-1RFC\s0 for full list and source of this file for local extensions)
.SS "\fInative_code()\fP"
.IX Subsection "native_code()"
gives the true status code we got back from registry (this breaks the encapsulation provided by Net::DRI, you should not use it if possible)
.SS "\fImessage()\fP"
.IX Subsection "message()"
gives the message attached to the the status code we got back from registry
.SS "\fIlang()\fP"
.IX Subsection "lang()"
gives the language in which the message above is written
.SS "\fIget_extended_results()\fP"
.IX Subsection "get_extended_results()"
gives back an array with additionnal result information from registry, especially in case of errors. If no data, an empty array is returned.
.PP
This method was previously called \fIinfo()\fR, before \f(CW\*(C`Net::DRI\*(C'\fR version 0.92_01
.SS "\fIget_data()\fP"
.IX Subsection "get_data()"
See explanation of data stored in \*(L"\s-1DESCRIPTION\s0\*(R". Can be called with one or three parameters and always returns a single value (or undef if failure).
.PP
With three parameters, it returns the value associated to the three keys/subkeys passed. Example: \f(CW\*(C`get_data("domain","example.com","exist")\*(C'\fR will return
0 or 1 depending if the domain exists or not, after a domain check or domain info operation.
.PP
With only one parameter, it will verify there is only one branch (besides session/exchange and message/info), and if so returns the data associated
to the parameter passed used as the third key. Otherwise will return undef.
.PP
Please note that the input \s-1API\s0 is \fInot\fR the same as the one used for \f(CW\*(C`$dri\-\*(C'\fR\fIget_info()\fR>.
.SS "\fIget_data_collection()\fP"
.IX Subsection "get_data_collection()"
See explanation of data stored in \*(L"\s-1DESCRIPTION\s0\*(R". Can be called with either zero, one or two parameters and may return a list or a single value
depending on calling context (and respectively an empty list or undef in case of failure).
.PP
With no parameter, it returns the whole data as reference to an hash with 2 levels beneath as explained in \*(L"\s-1DESCRIPTION\s0\*(R" in scalar context, or
the list of keys of this hash in list context.
.PP
With one parameter, it returns the hash referenced by the key given as argument at first level in scalar context,
or the list of keys of this hash in list context.
.PP
With two parameters, it walks down two level of the hash using the two parameters as key and subkey and returns the bottom hash referenced
in scalar context, or the list of keys of this hash in list context.
.PP
Please note that in all cases you are given references to the data itself, not copies. You should not try to modify it in any way, but just read it.
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
returns a string with all details, with the extended_results part if passed a true value
.SS "\fIprint()\fP"
.IX Subsection "print()"
same as CORE::print($rs\->\fIas_string\fR\|(0))
.SS "\fIprint_full()\fP"
.IX Subsection "print_full()"
same as CORE::print($rs\->\fIas_string\fR\|(1))
.SS "\fItrid()\fP"
.IX Subsection "trid()"
in scalar context, gives the transaction id (our transaction id, that is the client part in \s-1EPP\s0) which has generated this result,
in array context, gives the transaction id followed by other ids given by registry (example in \s-1EPP:\s0 server transaction id)
.SS "\fIis_pending()\fP"
.IX Subsection "is_pending()"
returns 1 if the last operation was flagged as pending by registry (asynchronous handling)
.SS "\fIis_closing()\fP"
.IX Subsection "is_closing()"
returns 1 if the last operation made the registry close the connection (should not happen often)
.SS "is(\s-1NAME\s0)"
.IX Subsection "is(NAME)"
if you really need to test some other codes (this should not happen often), you can using symbolic names
defined inside this module (see source).
Going that way makes sure you are not hardcoding numbers in your application, and you do not need
to import variables from this module to your application.
.SH "SUPPORT"
.IX Header "SUPPORT"
For now, support questions should be sent to:
.PP
<netdri@dotandco.com>
.PP
Please also see the \s-1SUPPORT\s0 file in the distribution.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://www.dotandco.com/services/software/Net\-DRI/
.SH "AUTHOR"
.IX Header "AUTHOR"
Patrick Mevzek, <netdri@dotandco.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005,2006,2008\-2010 Patrick Mevzek <netdri@dotandco.com>.
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
See the \s-1LICENSE\s0 file that comes with this distribution for more details.
